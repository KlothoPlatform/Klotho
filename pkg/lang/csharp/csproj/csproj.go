package csproj

import (
	"io"
	"sync"

	"github.com/beevik/etree"
	"github.com/klothoplatform/klotho/pkg/errors"
	klotho_io "github.com/klothoplatform/klotho/pkg/io"
)

type CSProjFile struct {
	path             string
	content          *etree.Document
	additionalConfig *additionalConfig
}

func NewCSProjFile(path string, content io.Reader) (*CSProjFile, error) {
	doc := etree.NewDocument()
	_, err := doc.ReadFrom(content)
	if err != nil {
		err = errors.WrapErrf(err, "could not decode XML for %s", path)
	}

	f := &CSProjFile{
		path:    path,
		content: doc,
		additionalConfig: &additionalConfig{
			AdditionalProperties: map[string]string{},
			PackageReferences:    map[string]string{},
		},
	}

	return f, err
}

func (f *CSProjFile) Clone() klotho_io.File {
	return &CSProjFile{
		path:             f.path,
		content:          f.content.Copy(),
		additionalConfig: f.additionalConfig.Clone(),
	}
}

func (f *CSProjFile) Path() string {
	return f.path
}

func (f *CSProjFile) WriteTo(out io.Writer) (int64, error) {
	f.addKlothoProperties()
	f.content.Indent(2)
	return f.content.WriteTo(out)
}

type additionalConfig struct {
	AdditionalProperties map[string]string
	PackageReferences    map[string]string
	mu                   sync.Mutex
}

func (n *additionalConfig) Clone() *additionalConfig {
	n.mu.Lock()
	defer n.mu.Unlock()

	c := &additionalConfig{
		PackageReferences:    make(map[string]string),
		AdditionalProperties: make(map[string]string),
	}
	for k, v := range n.PackageReferences {
		c.PackageReferences[k] = v
	}
	for k, v := range n.AdditionalProperties {
		c.AdditionalProperties[k] = v
	}

	return c
}

func (f *CSProjFile) AddProperty(name string, value string) {
	f.additionalConfig.AdditionalProperties[name] = value
}

func (f *CSProjFile) addKlothoProperties() {
	pGroup := etree.NewElement("PropertyGroup")
	pGroup.AddChild(etree.NewComment("Generated by Klotho"))
	for k, v := range f.additionalConfig.AdditionalProperties {
		e := etree.NewElement(k)
		e.SetText(v)
		pGroup.AddChild(e)
	}
	f.content.FindElement("//Project").AddChild(pGroup)
}

func (f *CSProjFile) GetProperty(name string) (string, bool) {
	elements := f.content.FindElements("//Project//PropertyGroup")
	for _, e := range elements {
		for _, c := range e.Child {
			if p, ok := c.(*etree.Element); ok {
				if t := p.FullTag(); name == t {
					return p.Text(), true
				}

			}
		}
	}
	return "", false
}
